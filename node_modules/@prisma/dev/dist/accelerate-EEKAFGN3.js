import{b as i,d as x,e as d}from"./chunk-7NDL3ECU.js";import"./chunk-ITQ6ILGR.js";import{HTTPException as re}from"hono/http-exception";import{Hono as ae}from"hono/tiny";import{validator as c}from"hono/validator";import{array as L,literal as k,minLength as B,object as U,pipe as N,safeParse as D,string as F,union as Q}from"valibot";var X=U({tags:Q([N(L(F()),B(1)),k("all")])});async function E(e){let{output:n,success:t}=D(X,await e.req.json(),{abortEarly:!0});return t?n:e.text("Invalid input",400)}import{parseDuration as v,parseSize as Y,Server as z}from"@prisma/query-plan-executor";import{version as P}from"@prisma/query-plan-executor";var T;async function O(e){return T===void 0&&(T=await z.create({databaseUrl:e.get("db").connectionString,maxResponseSize:Y("128 MiB"),queryTimeout:v("PT5M"),maxTransactionTimeout:v("PT5M"),maxTransactionWaitTime:v("PT5M"),perRequestLogContext:{logFormat:"text",logLevel:e.get("debug")?"debug":"off"}})),T}import{Buffer as I}from"buffer";import{getSchema as G,printSchema as W}from"@mrleebo/prisma-ast";var l=new Map;async function H(e){let t=new TextEncoder().encode(e),r=await crypto.subtle.digest("SHA-256",t);return Array.from(new Uint8Array(r)).map(s=>s.toString(16).padStart(2,"0")).join("")}function C(e){let n=e.req.param("schemaHash"),t=l.get(n);return t==null?e.json({EngineNotStarted:{reason:"SchemaMissing"}},404):{schemaHash:n,schemas:t}}async function R(e,n,t){let r=I.from(e,"base64").toString("utf8"),a=G(r),o=a.list.find(f=>f.type==="datasource");if(!o)throw new Error("No datasource block found in schema.");let s=o.assignments.find(f=>f.type==="assignment"&&f.key==="url");s?s.value=`"${n.toString()}"`:o.assignments.push({key:"url",type:"assignment",value:`"${n.toString()}"`});let m=W(a);t&&console.log("[Accelerate] schema with override:",m);let S=await H(m);return{base64Override:I.from(m,"utf8").toString("base64"),overrideHash:S}}function g(e){let{req:n}=e;return{traceparent:n.header("traceparent"),"X-capture-telemetry":n.header("X-capture-telemetry")}}import{integer as q,looseObject as K,minValue as A,number as w,object as J,optional as Z,pipe as _,safeParse as M,string as $,union as ee}from"valibot";var te=J({isolation_level:Z($()),max_wait:_(w(),q(),A(0)),timeout:_(w(),q(),A(0))});async function V(e){let{issues:n,output:t,success:r}=M(te,await e.req.json(),{abortEarly:!0});return r?t:e.json({EngineNotStarted:{reason:"InvalidRequest",issues:n}},400)}var ne=K({id:ee([$(),w()])});function j(e,n){let{output:t,success:r}=M(ne,e);return r?t:n.json({EngineMalfunction:{}},500)}var y=new ae;y.post("/invalidate",c("header",i),async e=>{let n=await E(e);return n instanceof Response?n:e.body(null)});var oe="/:clientVersion/:schemaHash",h=y.basePath(oe);y.route("/",h);var se=["/graphql","/itx/:transactionId/graphql"];h.on("POST",[...se],c("header",i),async e=>{let{req:n}=e;try{let t=await b(e);if(t instanceof Response)return t;let r=await n.text(),a=n.param("transactionId"),o=await t.request(r,{...g(e),"X-transaction-id":a});return e.text(o)}catch(t){return d(t,e)}});h.basePath("/itx/:transactionId").on("POST",["/commit","/rollback"],c("header",i),async e=>{let{req:n}=e;try{let t=await b(e);if(t instanceof Response)return t;let a=`${n.routePath.split("/").filter(Boolean).at(-1)}Transaction`,o=n.param("transactionId"),s=await t[a](o,g(e));return e.json(s)}catch(t){return d(t,e)}});h.put("/schema",c("header",i),async e=>{let{req:n}=e,t=await n.text();if(!t)return e.text("Missing schema",400);let r=n.param("schemaHash"),a=l.get(r);if(a==null){if(r!==await H(t))return e.text("Schema hash mismatch",400);let o=await R(t,e.get("db").prismaORMConnectionString,e.get("debug"));return l.set(r,{base64Original:t,...o}),e.text(r)}return t!==a.base64Original?e.text("Schema mismatch",400):e.text(r)});h.post("/transaction/start",c("header",i),async e=>{let{req:n}=e,t=await V(e);if(t instanceof Response)return t;try{let r=await b(e);if(r instanceof Response)return r;let a=await r.startTransaction(t,g(e)),o=j(a,e);if(o instanceof Response)return o;let{id:s}=o,m=n.param("clientVersion"),S=n.param("schemaHash");return e.json({...a,"data-proxy":{endpoint:`${new URL(n.url).origin}/${m}/${S}/itx/${s}`}})}catch(r){return d(r,e)}});async function b(e){let{req:n}=e,t=C(e);if(t instanceof Response)return t;let{base64Override:r,overrideHash:a}=t.schemas;return await x.get({base64Schema:r,clientVersion:process.env.PRISMA_DEV_FORCE_CLIENT_VERSION||n.param("clientVersion"),debug:e.get("debug"),platform:e.get("platform"),schemaHash:a})}var ie=[["/connection-info","GET"],["/query","POST"],["/transaction/start","POST"],["/transaction/:transactionId/commit","POST"],["/transaction/:transactionId/query","POST"],["/transaction/:transactionId/rollback","POST"]];for(let[e,n]of ie)y.on(n,e,c("header",i),async t=>{let r=t.req.header("prisma-engine-hash");if(r!=="0.0.0"&&r!==P)throw new re(400,{message:`Using an HTTP connection string is not supported with Prisma Client version ${r} by this version of \`prisma dev\`. Please either use a direct TCP connection string or upgrade your client to version ${P}.`});return await(await O(t)).fetch(t.req.raw)});export{y as accelerateRoute};
